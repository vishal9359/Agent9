"""
Agent9 - C++ function flowchart generator (AST-driven, low-hallucination)

Major goals (from requirements):
- Work on any C/C++ project: use libclang AST to parse.
- Generate a JSON list per parsed file with: name, location, description, mermaid flowchart, image path.
- Flowchart must be logically correct (control flow), valid Mermaid, and include function calls as black boxes.
- Do NOT go inside callees.
- Use open-source LLM via Ollama (ChatOllama).

Key approach to reduce hallucinations on large functions (300-600+ lines):
- AST deterministically defines control-flow (if/loop/switch/try/return/break/continue).
- LLM is used ONLY to summarize *small* basic blocks (<= MAX_BLOCK_LINES lines) into short labels.
- Mermaid is composed by this code (not generated by LLM).
"""

from __future__ import annotations

import argparse
import json
import os
import re
import subprocess
from collections import defaultdict
from dataclasses import dataclass
from typing import Optional

from clang import cindex
from docx import Document
from docx.shared import Inches
from langchain.messages import HumanMessage
from langchain_ollama import ChatOllama


# OPTIONAL: Set explicitly if needed
# cindex.Config.set_library_file("/usr/lib/llvm-18/lib/libclang.so")

SUPPORTED_EXT = (".c", ".cpp", ".cc", ".cxx")

# Paths (update for your environment)
mermaid_path = "/home/workspace/mermaid_converter"
out_dir = "/home/workspace/adk/gemma-code/orchestrator/docs"

# LLM (open-source) via Ollama
llm = ChatOllama(model="gpt-oss", temperature=0.2, top_k=10, top_p=0.9)

# Chunking/safety limits
MAX_BLOCK_LINES = 80        # max lines per LLM block summary
MAX_LABEL_CHARS = 160       # max label length in Mermaid
MAX_SUMMARY_RETRIES = 3     # per block summary

# Split long straight-line code into segments to avoid a single giant box
PENDING_SEGMENT_MAX_LINES = 35
PENDING_SEGMENT_MAX_STMTS = 14

KEYWORD_TOKENS = {
    "if",
    "for",
    "while",
    "switch",
    "return",
    "new",
    "delete",
    "sizeof",
    "static_cast",
    "dynamic_cast",
    "const_cast",
    "reinterpret_cast",
}

# Common library/API calls to ignore in flowchart labels
COMMON_API_CALLS = {
    "strlen", "strcmp", "strncmp", "strcpy", "strncpy", "strcat", "strncat",
    "memcpy", "memmove", "memcmp", "memset",
    "printf", "fprintf", "sprintf", "snprintf", "scanf", "fscanf", "sscanf",
    "puts", "fputs", "putchar", "getchar",
    "malloc", "calloc", "realloc", "free",
    "memset",
    "exit", "abort",
    "cout", "cin", "cerr", "clog",
    "push_back", "emplace_back", "insert", "erase", "find", "size", "empty",
    "begin", "end", "clear", "resize", "reserve",
    "move", "sort",
}


def _ck(name: str):
    """
    Return cindex.CursorKind.<name> if available in this libclang binding, else None.
    This avoids crashes across different clang/python bindings.
    """
    return getattr(cindex.CursorKind, name, None)


# CursorKind compatibility (varies by libclang version / python bindings)
CK_CXX_TRY = _ck("CXX_TRY_STMT") or _ck("TRY_STMT")
CK_CXX_CATCH = _ck("CXX_CATCH_STMT")
CK_CXX_FOR_RANGE = _ck("CXX_FOR_RANGE_STMT")


def _kind_str(kind) -> str:
    """
    Best-effort kind name across clang bindings.
    """
    return (getattr(kind, "name", None) or getattr(kind, "spelling", None) or str(kind) or "").upper()


def _is_range_for_cursor(cursor) -> bool:
    if cursor is None:
        return False
    k = _kind_str(getattr(cursor, "kind", ""))
    return ("FOR_RANGE" in k) or ("CXX_FOR_RANGE" in k)


def is_cpp_file(path: str) -> bool:
    return path.endswith(SUPPORTED_EXT)


def get_module_name(file_path: str, root_dir: str) -> str:
    rel = os.path.relpath(file_path, root_dir)
    no_ext = os.path.splitext(rel)[0]
    return ".".join(no_ext.split(os.sep))


def node_uid(cursor) -> str:
    loc = cursor.location
    return f"{cursor.spelling}:{loc.file.name}:{loc.line}"


def clean_unicode_chars(text: str) -> str:
    """Keep printable ASCII + newlines/tabs only."""
    if not text:
        return ""
    ascii_text = text.encode("ascii", "ignore").decode("ascii")
    ascii_text = re.sub(r"[^\x20-\x7E\n\r\t]", "", ascii_text)
    return ascii_text


def clamp_label(s: str) -> str:
    s = clean_unicode_chars(s or "")
    s = re.sub(r"\s+", " ", s).strip()
    if len(s) > MAX_LABEL_CHARS:
        s = s[: MAX_LABEL_CHARS - 3].rstrip() + "..."
    return s


def _replace_function_calls(text: str, for_condition: bool) -> str:
    """
    Replace function calls in a Mermaid-safe way.
    - For conditions: keep function name without "call" (avoid "call if")
    - For non-conditions: use "call <name>" to show black-box calls
    """
    if not text:
        return text

    def repl(match: re.Match) -> str:
        name = match.group(1)
        if name in KEYWORD_TOKENS:
            return name
        return f"{name}()"

    # Method calls: obj.method(...) or ptr->method(...)
    def repl_method(match: re.Match) -> str:
        obj = match.group(1)
        method = match.group(2)
        if method in KEYWORD_TOKENS:
            return f"{obj} {method}"
        # Prefer just the method name as a black-box call.
        return f"{method}()"

    text = re.sub(r"\b([A-Za-z_][A-Za-z0-9_:]*)\s*(?:\.|->)\s*([A-Za-z_][A-Za-z0-9_]*)\s*\([^)]*\)", repl_method, text)
    text = re.sub(r"\b([A-Za-z_][A-Za-z0-9_]*)\s*\([^)]*\)", repl, text)
    return text


def clean_label_text(label: str, for_condition: bool = False) -> str:
    """
    Mermaid-safe, readable label:
    - ASCII only
    - Keep compact pseudo-code for process blocks
    - Sanitize punctuation that can break Mermaid
    """
    label = clean_unicode_chars(label or "")

    # Replace function-call syntax first (turn Foo(...) into Foo()).
    label = _replace_function_calls(label, for_condition=for_condition)

    # Keep operators for conditions and process labels (user requested x<0, y>=0, etc.)
    # Only normalize boolean ops for readability.
    label = label.replace("&&", " and ").replace("||", " or ")

    # Remove brackets/braces/statement terminators that can break Mermaid parsing.
    # Keep parentheses so calls like Foo() remain visible.
    label = re.sub(r"[{}\[\];]", " ", label)
    label = label.replace("?", " ")

    label = re.sub(r"\s+", " ", label).strip()
    return clamp_label(label) or "Process block"


def clean_condition_text(label: str) -> str:
    """
    Clean condition expressions for decision nodes.
    Removes leading control keywords and avoids "call <keyword>" artifacts.
    """
    label = clean_unicode_chars(label or "")
    label = re.sub(r"^\s*(if|for|while|switch)\b", "", label, flags=re.IGNORECASE).strip()
    # Keep operators and function-call parentheses in conditions
    return clean_label_text(label, for_condition=True)


def extract_source_lines(file_lines: list[str], start_line: int, end_line: int) -> list[str]:
    start_line = max(1, start_line)
    end_line = max(start_line, end_line)
    return [l.rstrip("\n") for l in file_lines[start_line - 1 : min(len(file_lines), end_line)]]


def cursor_text(cursor, file_lines: list[str]) -> str:
    if not cursor or not getattr(cursor, "extent", None):
        return ""
    return "\n".join(extract_source_lines(file_lines, cursor.extent.start.line, cursor.extent.end.line)).strip()


def extract_function_calls_from_text(text: str) -> list[str]:
    """Deterministic call extraction (for summary prompt only)."""
    pattern = r"\b([A-Za-z_][A-Za-z0-9_]*)\s*\("
    matches = re.findall(pattern, text or "")
    keywords = {
        "if", "while", "for", "switch", "return", "new", "delete", "sizeof",
        "static_cast", "dynamic_cast", "const_cast", "reinterpret_cast",
        "catch", "throw", "try",
    }
    out: list[str] = []
    seen = set()
    for m in matches:
        if m in keywords:
            continue
        if m in COMMON_API_CALLS:
            continue
        if m not in seen:
            out.append(m)
            seen.add(m)
    return out


def _append_calls_to_label(label: str, calls: list[str]) -> str:
    """
    Ensure custom function calls are explicitly shown in the label.
    """
    if not calls:
        return clean_label_text(label)

    base = clean_label_text(label)
    missing = [c for c in calls if not re.search(rf"\b{re.escape(c)}\b", base, flags=re.IGNORECASE)]
    if not missing:
        return base

    call_text = ", ".join(f"{c}()" for c in missing[:3])
    merged = f"{base}; {call_text}" if base else call_text
    return clamp_label(merged)


def summarize_block_with_llm(block_text: str, extra_calls: Optional[list[str]] = None) -> str:
    """
    Summarize a block into a short phrase. Chunk deterministically if too large.
    The LLM never sees the whole function, only small blocks.
    """
    block_text = clean_unicode_chars(block_text or "").strip()
    if not block_text:
        return "Process block"

    calls = extract_function_calls_from_text(block_text)
    if extra_calls:
        for c in extra_calls:
            if c and c not in calls:
                calls.append(c)
    lines = block_text.splitlines()
    if len(lines) > MAX_BLOCK_LINES:
        parts: list[str] = []
        for i in range(0, len(lines), MAX_BLOCK_LINES):
            chunk = "\n".join(lines[i : i + MAX_BLOCK_LINES]).strip()
            parts.append(_summarize_once(chunk))
        summary = clamp_label(" / ".join(parts)) or "Process block"
        return _append_calls_to_label(summary, calls)

    summary = _summarize_once(block_text)
    return _append_calls_to_label(summary, calls)


def _summarize_once(block_text: str) -> str:
    """
    Prompt for compact pseudo-code labels.
    """
    calls = extract_function_calls_from_text(block_text)
    calls_str = ", ".join(calls[:10]) if calls else "none"

    # Prompt: pseudo-code + minimal intent (avoid over-gist)
    prompt = (
        "You are analyzing C++ code for a flowchart.\n"
        "Goal: Produce a short label for a PROCESS box.\n"
        "Prefer pseudo-code (assignments + calls) with minimal intent words.\n"
        "\n"
        "Rules:\n"
        "- Output 1 to 3 short pseudo-code lines separated by '<br/>'\n"
        "- Keep important assignments and calls\n"
        "- If calling functions, use '<name>()'\n"
        "- Do NOT output control-flow keywords (if/for/while/switch/try/catch)\n"
        "- Avoid long prose; keep it close to code\n"
        "- ASCII only\n"
        "\n"
        f"Function calls detected: {calls_str}\n"
        "\n"
        "Code block:\n"
        "{block}\n"
        "\n"
        "Pseudo-code label:"
    )
    query = prompt.format(block=block_text)

    for _ in range(MAX_SUMMARY_RETRIES):
        try:
            resp = llm.invoke([HumanMessage(query)])
            phrase = clean_label_text(resp.content)
            if phrase:
                return phrase
        except Exception:
            pass
    return "Process block"


@dataclass
class Graph:
    nodes: dict[str, dict]  # id -> {"shape": str, "label": str}
    edges: list[tuple[str, str, str]]  # (src, dst, label)


class FlowBuilder:
    """
    Deterministic flow builder from AST statements.
    Basic blocks = grouped consecutive non-control statements.
    """

    def __init__(self, file_lines: list[str], root_dir: str, file_path: str):
        self.file_lines = file_lines
        self.root_dir = os.path.abspath(root_dir or "")
        self.file_path = os.path.abspath(file_path or "")
        self.nodes: dict[str, dict] = {}
        self.edges: list[tuple[str, str, str]] = []
        self._next_id = 1
        self.loop_stack: list[tuple[str, str]] = []  # (continue_target, break_target)
        self.switch_stack: list[str] = []  # break_target
        self.terminal_exits: list[str] = []

    def _is_under_root(self, path: str) -> bool:
        if not path or not self.root_dir:
            return False
        try:
            p = os.path.normcase(os.path.abspath(path))
            r = os.path.normcase(os.path.abspath(self.root_dir))
            return os.path.commonpath([p, r]) == r
        except Exception:
            return False

    def _collect_custom_calls(self, cursor) -> list[str]:
        """
        Collect callees whose definitions are inside the parsed project root.
        This avoids hardcoding API names and makes "custom call" detection robust.
        """
        out: list[str] = []
        seen = set()
        if cursor is None:
            return out

        stack = [cursor]
        while stack:
            n = stack.pop()
            try:
                kname = _kind_str(getattr(n, "kind", ""))
                if "CALL_EXPR" in kname:
                    ref = getattr(n, "referenced", None)
                    ref_file = None
                    if ref is not None and getattr(ref, "location", None) is not None and getattr(ref.location, "file", None) is not None:
                        ref_file = ref.location.file.name
                    if ref_file and self._is_under_root(ref_file):
                        name = (getattr(ref, "spelling", None) or getattr(n, "spelling", None) or "").strip()
                        if name and name not in seen:
                            out.append(name)
                            seen.add(name)
                for ch in n.get_children():
                    stack.append(ch)
            except Exception:
                continue
        return out

    def new_node(self, shape: str, label: str) -> str:
        nid = f"n{self._next_id}"
        self._next_id += 1
        clean = clean_label_text(label)
        self.nodes[nid] = {
            "shape": shape,
            "label": clean,
        }
        return nid

    def add_edge(self, src: str, dst: str, label: str = ""):
        if not src or not dst:
            return
        self.edges.append((src, dst, clean_label_text(label) if label else ""))

    def build_function(self, fn_cursor) -> Graph:
        body = None
        for ch in fn_cursor.get_children():
            if ch.kind == cindex.CursorKind.COMPOUND_STMT:
                body = ch
                break

        if body is None:
            n = self.new_node("process", "No implementation")
            self.add_edge("Start", n)
            self.add_edge(n, "End")
            return Graph(self.nodes, self.edges)

        entry, exits = self.build_compound(body)
        self.add_edge("Start", entry)
        for ex in exits:
            self.add_edge(ex, "End")
        for ex in self.terminal_exits:
            self.add_edge(ex, "End")
        return Graph(self.nodes, self.edges)

    def build_stmt(self, cursor) -> tuple[str, list[str]]:
        k = cursor.kind

        if _is_range_for_cursor(cursor):
            return self._build_range_for(cursor)

        if k == cindex.CursorKind.RETURN_STMT:
            n = self.new_node("process", "Return from function")
            self.terminal_exits.append(n)
            return n, []

        if k == cindex.CursorKind.BREAK_STMT:
            n = self.new_node("process", "Break")
            if self.switch_stack:
                self.add_edge(n, self.switch_stack[-1])
            elif self.loop_stack:
                self.add_edge(n, self.loop_stack[-1][1])
            return n, []

        if k == cindex.CursorKind.CONTINUE_STMT:
            n = self.new_node("process", "Continue")
            if self.loop_stack:
                self.add_edge(n, self.loop_stack[-1][0])
            return n, []

        if k == cindex.CursorKind.IF_STMT:
            return self._build_if(cursor)

        if k in (cindex.CursorKind.FOR_STMT, cindex.CursorKind.WHILE_STMT, cindex.CursorKind.DO_STMT):
            header_text = cursor_text(cursor, self.file_lines)
            if k == cindex.CursorKind.FOR_STMT and re.search(r"for\s*\([^)]*:[^)]*\)", header_text):
                return self._build_range_for(cursor)
            return self._build_loop(cursor)

        if CK_CXX_FOR_RANGE is not None and k == CK_CXX_FOR_RANGE:
            return self._build_range_for(cursor)

        if k == cindex.CursorKind.SWITCH_STMT:
            return self._build_switch(cursor)

        if CK_CXX_TRY is not None and k == CK_CXX_TRY:
            return self._build_try(cursor)

        return self.build_compound(cursor)

    def build_compound(self, cursor) -> tuple[str, list[str]]:
        """
        Build flow from a compound statement.
        Groups consecutive non-control statements.
        """
        if cursor is None:
            n = self.new_node("process", "No operation")
            return n, [n]

        if cursor.kind != cindex.CursorKind.COMPOUND_STMT:
            text = cursor_text(cursor, self.file_lines)
            calls = self._collect_custom_calls(cursor)
            n = self.new_node("process", summarize_block_with_llm(text, extra_calls=calls))
            return n, [n]

        children = list(cursor.get_children())
        entry = None
        curr_exits: list[str] = []
        pending: list = []

        CONTROL_KINDS = {
            cindex.CursorKind.IF_STMT,
            cindex.CursorKind.FOR_STMT,
            cindex.CursorKind.WHILE_STMT,
            cindex.CursorKind.DO_STMT,
            CK_CXX_FOR_RANGE,
            cindex.CursorKind.SWITCH_STMT,
            CK_CXX_TRY,
            cindex.CursorKind.RETURN_STMT,
            cindex.CursorKind.BREAK_STMT,
            cindex.CursorKind.CONTINUE_STMT,
        }
        CONTROL_KINDS = {k for k in CONTROL_KINDS if k is not None}

        def _is_control_stmt(c) -> bool:
            if c is None:
                return False
            if _is_range_for_cursor(c):
                return True
            # Some bindings represent range-for as FOR_STMT only; detect via text.
            if c.kind == cindex.CursorKind.FOR_STMT:
                ht = cursor_text(c, self.file_lines)
                if re.search(r"for\s*\([^)]*:[^)]*\)", ht):
                    return True
            return c.kind in CONTROL_KINDS

        def flush_pending():
            nonlocal entry, curr_exits, pending
            if not pending:
                return

            # Split long straight-line code into smaller segments
            segments: list[list] = []
            current: list = []
            current_lines = 0

            for stmt in pending:
                stmt_text = cursor_text(stmt, self.file_lines)
                stmt_lines = max(1, len(stmt_text.splitlines())) if stmt_text else 1

                if (
                    current
                    and (
                        len(current) >= PENDING_SEGMENT_MAX_STMTS
                        or (current_lines + stmt_lines) > PENDING_SEGMENT_MAX_LINES
                    )
                ):
                    segments.append(current)
                    current = []
                    current_lines = 0

                current.append(stmt)
                current_lines += stmt_lines

            if current:
                segments.append(current)

            for seg in segments:
                text = "\n".join(t for t in (cursor_text(s, self.file_lines) for s in seg) if t)
                seg_calls: list[str] = []
                seen_calls = set()
                for s in seg:
                    for cname in self._collect_custom_calls(s):
                        if cname not in seen_calls:
                            seg_calls.append(cname)
                            seen_calls.add(cname)
                label = summarize_block_with_llm(text, extra_calls=seg_calls)
                n = self.new_node("process", label)

                if entry is None:
                    entry = n
                if curr_exits:
                    for ex in curr_exits:
                        self.add_edge(ex, n)
                curr_exits = [n]

            pending = []

        # Main walk
        for child in children:
            if _is_control_stmt(child):
                flush_pending()
                s_entry, s_exits = self.build_stmt(child)

                if entry is None:
                    entry = s_entry
                if curr_exits:
                    for ex in curr_exits:
                        self.add_edge(ex, s_entry)

                curr_exits = s_exits
            else:
                pending.append(child)

        flush_pending()

        if entry is None:
            n = self.new_node("process", "No operation")
            return n, [n]

        return entry, curr_exits

    def _build_if(self, cursor) -> tuple[str, list[str]]:
        children = list(cursor.get_children())
        cond = children[0] if children else None
        then_stmt = children[1] if len(children) > 1 else None
        else_stmt = children[2] if len(children) > 2 else None

        cond_text = cursor_text(cond, self.file_lines) or "condition"
        cond_label = clean_condition_text(cond_text)
        d = self.new_node("decision", f"Check {cond_label}")

        t_entry, t_exits = self.build_compound(then_stmt)
        self.add_edge(d, t_entry, "true")

        if else_stmt:
            f_entry, f_exits = self.build_compound(else_stmt)
            self.add_edge(d, f_entry, "false")
            return d, (t_exits + f_exits)

        # no else: false falls through
        return d, (t_exits + [d])

    def _build_loop(self, cursor) -> tuple[str, list[str]]:
        k = cursor.kind
        children = list(cursor.get_children())

        cond = None
        body = None
        if k == cindex.CursorKind.WHILE_STMT:
            cond = children[0] if len(children) > 0 else None
            body = children[1] if len(children) > 1 else None
        elif k == cindex.CursorKind.DO_STMT:
            body = children[0] if len(children) > 0 else None
            cond = children[1] if len(children) > 1 else None
        else:  # FOR
            # Prefer parsing header text to avoid including init/inc in the condition label.
            header_text = cursor_text(cursor, self.file_lines)
            m = re.search(r"for\s*\(([^)]*)\)", header_text)
            if m and ";" in m.group(1):
                parts = [p.strip() for p in m.group(1).split(";")]
                if len(parts) >= 2:
                    cond_text = parts[1]
                    cond = None
                else:
                    cond_text = ""
            else:
                cond_text = ""
                cond = children[1] if len(children) > 1 else None
            body = children[-1] if children else None

        cond_text = (cond_text or cursor_text(cond, self.file_lines) or "loop condition").strip()
        cond_label = clean_condition_text(cond_text)
        check = self.new_node("decision", f"Check {cond_label}")
        after = self.new_node("process", "After loop")

        self.loop_stack.append((check, after))
        b_entry, b_exits = self.build_compound(body)
        self.loop_stack.pop()

        if k == cindex.CursorKind.DO_STMT:
            entry = b_entry
            for ex in b_exits:
                self.add_edge(ex, check)
            self.add_edge(check, b_entry, "true")
            self.add_edge(check, after, "false")
            return entry, [after]

        self.add_edge(check, b_entry, "true")
        self.add_edge(check, after, "false")
        for ex in b_exits:
            self.add_edge(ex, check)
        return check, [after]

    def _build_range_for(self, cursor) -> tuple[str, list[str]]:
        children = list(cursor.get_children())
        body = children[-1] if children else None

        header_text = cursor_text(cursor, self.file_lines)
        match = re.search(r"for\s*\(([^)]*)\)", header_text)
        cond_text = match.group(1) if match else "range"
        cond_label = clean_condition_text(cond_text)

        check = self.new_node("decision", f"For each {cond_label}")
        after = self.new_node("process", "After loop")

        self.loop_stack.append((check, after))
        b_entry, b_exits = self.build_compound(body)
        self.loop_stack.pop()

        self.add_edge(check, b_entry, "true")
        self.add_edge(check, after, "false")
        for ex in b_exits:
            self.add_edge(ex, check)
        return check, [after]

    def _build_switch(self, cursor) -> tuple[str, list[str]]:
        children = list(cursor.get_children())
        expr = children[0] if children else None
        body = children[1] if len(children) > 1 else None

        expr_text = cursor_text(expr, self.file_lines) or "expression"
        expr_label = clean_condition_text(expr_text)
        d = self.new_node("decision", f"Switch on {expr_label}")
        after = self.new_node("process", "After switch")

        self.switch_stack.append(after)

        cases = []
        default_case = None
        if body:
            for ch in body.get_children():
                if ch.kind == cindex.CursorKind.CASE_STMT:
                    cases.append(ch)
                elif ch.kind == cindex.CursorKind.DEFAULT_STMT:
                    default_case = ch

        built: list[tuple[str, str, list[str]]] = []
        for c in cases:
            raw = cursor_text(c, self.file_lines)
            case_label = clean_label_text(raw.split(":")[0] if ":" in raw else "case")
            c_children = list(c.get_children())
            c_body = c_children[-1] if c_children else None
            entry, exits = self.build_compound(c_body)
            built.append((case_label, entry, exits))

        if default_case:
            d_children = list(default_case.get_children())
            d_body = d_children[-1] if d_children else None
            entry, exits = self.build_compound(d_body)
            built.append(("default", entry, exits))

        for lbl, entry, _ in built:
            self.add_edge(d, entry, lbl)

        # Best-effort fallthrough
        for i in range(len(built) - 1):
            next_entry = built[i + 1][1]
            for ex in built[i][2]:
                self.add_edge(ex, next_entry, "fallthrough")

        if built:
            for ex in built[-1][2]:
                self.add_edge(ex, after)
        else:
            self.add_edge(d, after, "default")

        self.switch_stack.pop()
        return d, [after]

    def _build_try(self, cursor) -> tuple[str, list[str]]:
        children = list(cursor.get_children())
        try_block = children[0] if children else None
        catches = children[1:] if len(children) > 1 else []

        if CK_CXX_CATCH is not None:
            catches = [c for c in catches if c.kind == CK_CXX_CATCH] or catches

        decision = self.new_node("decision", "Exception occurs")
        after = self.new_node("process", "After try catch")

        t_entry, t_exits = self.build_compound(try_block)
        self.add_edge(decision, t_entry, "no")
        for ex in t_exits:
            self.add_edge(ex, after)

        if catches:
            catch_text = "\n".join(t for t in (cursor_text(c, self.file_lines) for c in catches) if t)
            catch_label = summarize_block_with_llm(catch_text) if catch_text else "Handle exception"
            c_node = self.new_node("process", catch_label)
            self.add_edge(decision, c_node, "yes")
            self.add_edge(c_node, after)
        else:
            self.add_edge(decision, after, "yes")

        return decision, [after]


def render_mermaid(graph: Graph) -> str:
    """Render detailed (CFG-level) Mermaid flowchart."""
    lines = ["flowchart TD", "Start((Start))"]

    for nid, node in graph.nodes.items():
        shape = node["shape"]
        label = clean_label_text(node["label"])

        if shape == "decision":
            lines.append(f"{nid}{{{{{label}}}}}")
        else:
            lines.append(f"{nid}[{label}]")

    lines.append("End((End))")

    for src, dst, lbl in graph.edges:
        if lbl:
            lines.append(f"{src} --> |{clean_label_text(lbl)}| {dst}")
        else:
            lines.append(f"{src} --> {dst}")

    return "\n".join(lines) + "\n"


def validate_mermaid(mermaid: str) -> tuple[bool, Optional[str]]:
    if not mermaid or not mermaid.strip():
        return False, "Empty flowchart"
    if "flowchart" not in mermaid.lower():
        return False, "Missing flowchart declaration"
    if "Start((Start))" not in mermaid:
        return False, "Missing Start node"
    if "End((End))" not in mermaid:
        return False, "Missing End node"
    if "&#" in mermaid:
        return False, "HTML entities detected"
    for line in mermaid.splitlines():
        if line.count("-->") > 1:
            return False, "Multiple edges in one line"
    return True, None


def generate_flowchart_for_function(fn_cursor, file_lines: list[str], root_dir: str, file_path: str):
    """
    Generate flowcharts for a function.
    
    Returns:
    1) flowchart: str
    2) image: str|None
    3) feedback: Optional[str]
    """
    feedback = None

    # Build CFG
    builder = FlowBuilder(file_lines, root_dir=root_dir, file_path=file_path)
    graph = builder.build_function(fn_cursor)

    mermaid = render_mermaid(graph)

    ok, err = validate_mermaid(mermaid)
    if not ok:
        return (mermaid, None, f"Flowchart validation failed: {err}")

    # Generate images
    img = None

    currdir = os.getcwd()
    try:
        os.chdir(mermaid_path)

        subprocess.check_output(
            ["node", "index.js", mermaid, f"{fn_cursor.spelling}.png"],
            stderr=subprocess.STDOUT,
            timeout=30,
        )
        img = os.path.join(mermaid_path, f"{fn_cursor.spelling}.png")

    except Exception as e:
        feedback = f"Mermaid image generation failed: {str(e)[:200]}"
    finally:
        os.chdir(currdir)

    return (mermaid, img, feedback)


def generate_function_description(function_lines: list[str]) -> str:
    prompt = (
        "You are a C++ code documentation expert.\n"
        "Provide a concise 2-3 sentence description.\n"
        "Do not invent anything.\n\n"
        "Function:\n"
        "{function}\n"
        "Description:"
    )
    query = prompt.format(function="\n".join(function_lines[:120]))
    try:
        resp = llm.invoke([HumanMessage(query)])
        return clean_unicode_chars(resp.content).strip()
    except Exception:
        return "Description generation failed"


def extract_node_info(fn_cursor, file_path: str, module_name: str, root_dir: str) -> Optional[dict]:
    extent = fn_cursor.extent
    try:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            file_lines = f.readlines()

        function_lines = extract_source_lines(file_lines, extent.start.line, extent.end.line)
        function_lines = [l.rstrip() for l in function_lines if l.strip()]
        if not function_lines:
            return None

        flowchart, img, feedback = generate_flowchart_for_function(fn_cursor, file_lines, root_dir=root_dir, file_path=file_path)

        return {
            "uid": node_uid(fn_cursor),
            "name": fn_cursor.spelling,
            "line_start": extent.start.line,
            "column_start": extent.start.column,
            "line_end": extent.end.line,
            "column_end": extent.end.column,
            "file_name": file_path,
            "module_name": module_name,
            "description": generate_function_description(function_lines),
            "flowchart": flowchart,
            "feedback": feedback,
            "img": img,
            "callees": [],
            "callers": [],
        }
    except Exception as e:
        print(f"[WARN] extract_node_info failed for {fn_cursor.spelling}: {e}")
        return None


def visit(cursor, file_path: str, module_name: str, root_dir: str, nodes: dict, call_edges, current_fn_uid: Optional[str], visited=None):
    if visited is None:
        visited = set()

    if cursor.location.file and cursor.location.file.name != file_path:
        return

    fqn = f"{module_name}::{file_path}::{cursor.spelling}"
    if fqn in visited:
        return

    if cursor.is_definition() and cursor.kind in (
        cindex.CursorKind.FUNCTION_DECL,
        cindex.CursorKind.CXX_METHOD,
        cindex.CursorKind.CONSTRUCTOR,
        cindex.CursorKind.DESTRUCTOR,
    ):
        visited.add(fqn)
        uid = node_uid(cursor)
        if uid not in nodes and cursor.spelling:
            info = extract_node_info(cursor, file_path, module_name, root_dir=root_dir)
            if info:
                nodes[uid] = info
                current_fn_uid = uid

    if cursor.kind == cindex.CursorKind.CALL_EXPR and current_fn_uid:
        ref = cursor.referenced
        if ref and ref.spelling and ref.location.file:
            callee_uid = node_uid(ref)
            call_edges[current_fn_uid].add(callee_uid)

    for child in cursor.get_children():
        visit(child, file_path, module_name, root_dir, nodes, call_edges, current_fn_uid, visited)


def generate_word_document(data: list[dict], doc_name: str):
    doc = Document()
    for index, item in enumerate(data, start=1):
        doc.add_heading(f"1.1.{index} {item['name']}", level=1)
        table = doc.add_table(rows=2, cols=2, style="Table Grid")
        table.rows[0].cells[0].text = "Requirement ID"
        table.rows[0].cells[1].text = f"SAVV8-SwU-{index}"
        table.rows[1].cells[0].text = "Flowchart"

        if item.get("img") and os.path.exists(item["img"]):
            table.rows[1].cells[1].add_paragraph().add_run().add_picture(item["img"], width=Inches(6.0))
        else:
            table.rows[1].cells[1].text = item.get("feedback") or "Flowchart image not available"

    os.makedirs(os.path.dirname(doc_name), exist_ok=True)
    doc.save(doc_name)


def parse_file(index, file_path: str, root_dir: str, compile_args: list[str], out_nodes: dict, out_edges):
    module_name = get_module_name(file_path, root_dir)
    tu = index.parse(
        file_path,
        args=compile_args,
        options=cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD,
    )

    my_nodes: dict = {}
    my_edges = defaultdict(set)
    visit(tu.cursor, file_path, module_name, root_dir, my_nodes, my_edges, None)

    if not my_nodes:
        return

    base = os.path.splitext(os.path.basename(file_path))[0]
    meta_name = base
    if meta_name in out_nodes:
        meta_name = f"{meta_name}_{len(out_nodes)}"

    json_path = os.path.join(out_dir, f"{meta_name}.json")
    docx_path = os.path.join(out_dir, f"{base}.docx")

    generate_word_document(list(my_nodes.values()), docx_path)
    with open(json_path, "w", encoding="utf-8") as f:
        json.dump(list(my_nodes.values()), f, indent=2, ensure_ascii=False)

    out_nodes.update(my_nodes)
    out_edges.update(my_edges)


def parse_codebase(root_dir: str, compile_args: Optional[list[str]] = None) -> list[dict]:
    compile_args = compile_args or ["-std=c++17"]
    index = cindex.Index.create()
    nodes: dict = {}
    call_edges = defaultdict(set)

    for root, _, files in os.walk(root_dir):
        for f in files:
            if is_cpp_file(f):
                path = os.path.join(root, f)
                try:
                    parse_file(index, path, root_dir, compile_args, nodes, call_edges)
                except Exception as e:
                    print(f"[WARN] Failed to parse {path}: {e}")

    return list(nodes.values())


def main():
    parser = argparse.ArgumentParser(description="Generate AST-driven flowcharts for C++ functions")
    parser.add_argument("path", help="C++ codebase root directory")
    parser.add_argument("--std", default="c++17", help="C++ standard, e.g. c++17, c++20")
    parser.add_argument("--libclang", help="Path to libclang shared library")
    args = parser.parse_args()

    if args.libclang:
        cindex.Config.set_library_file(args.libclang)

    os.makedirs(out_dir, exist_ok=True)
    parse_codebase(args.path, compile_args=[f"-std={args.std}"])
    print("Done.")


if __name__ == "__main__":
    main()
